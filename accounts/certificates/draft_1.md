# Ender Certificates (draft 1)

> Last update: April 20th, 2024

All Ender services are built around one uniform accounts system (Ender Accounts), and Ender Accounts can be used in conjunction with other approved 3rd-party services. As such, the Accounts System must be built in a way that would make unauthorised actions impossible, with user-tight control, in addition to user-level individual protection and encryption. One way to keep up these standards, on the backend level, would be the use of a custom in-house CA, and require certificates to initiate API interactions.

The goal of using a custom CA, and building up from it to a complete accounts system, is to ensure the best protection and tight control even in cases when a vulnerability is discovered within the account system's infrastructure.

> This is a rough draft of the elements and structure of the certificates system! Please, do not hesitate to offer suggestions on how to improve it!

## Encryption and Signatures

Just like [TLS connections](https://en.wikipedia.org/wiki/Transport_Layer_Security), the certificate encryption protocol will be based on *asymmetric encryption* (also known as *Public-key cryptography*).

> Asymmetric encryption hugly operates on the fact that a specific *key pair* can be used to encrypt and decrypt data as follows:
>
> Data encrypted by one key can only be decrypted by the other key in such a pair.
>
> So, for example, data encrypted by the *public key* (the name of the key made available for the other party) can only be decrypted by the *private key* (the name of the key that only the server has access to)
>
> Symmetric encryption makes use of only one key, used to both encrypt and decrypt data!

All data saved on internal servers for long-term use will be encrypted using the user's *Data key* (using Symmetric encryption - not the *public key* or *private key*), data meant to be available for entities outside of the accounts system will be signed using the *private key*, and data sent by 3rd-party services will be encrypted using the *public key* (and later on it will be decrypted using the *private key* and re-encrypted using the *Data key* for data storage).

> Data Signing is the process of encryping a digest, usually called hashes (e.g. `SHA-256`), using the sender's *private key*.
>
> In such a setup, the receiver (who has access to the *public key*) can decrypt the signature and compare the digest against the digest of the received data in order to verify it's veracity.

The certificates generated by this system will make use of *Elliptic-Curve Cryptography* to encrypt user-generated data in transit and sign certificates.

> Note that you need to use `CSPRNG` to generate hash salts, and `OpenSSL` to generate safe key pairs.

### Secure Data Singing

In order to ensure that the contents of certificates generated by this system are not forged, all data will be signed. And, in order to ensure no manipulation of the signed data has occurred - *an example would be an attacker piecing together a bunch of known data from other certificates and its signature in order to forge a modified certificate that allows actions not allowed before* - *Enhanced Signatures* are needed.

*Enhanced Signatures* are a digest of the *original data* mixed with the *unique ID* of the certificate. (e.g. digest of {*N::\[X]*}, *X* being content, *N* being the certificate's *unique ID*)

The intended digest function is `bcrypt`.

> Note that each certificate, regardless of its type, has a *unique ID* that can be used to identify it within the in-house CA database!

## Standard Ender Certificate Data

Each Ender Certificate, regardless of type, includes all the following fields:

> (*S*): Includes a signed field!
>
> (*+S*): Includes an ID enhanced signed field! (*Unique ID* + data)
>
> (*KEY+S*): Includes a key enhanced signed field! (*Public Key* + data)

- **Version**: The version of the certificate data format
- **Serial Number** (*KEY+S*): The *unique ID* of the certificate within the CA's database (64bytes long, except for the root certificate)
- **Algorithm** (*+S*): The specific algorithm used to sign and encrypt data
- **Validity**
  - **Not Before** (*+S*): The timestamp of the date the certificate becomes effective
  - **Not After** (*+S*): The timestamp of the date the certificate's validity expires (can be `NULL`, then it expires when the issuer's certificate expires)
- **Issuer**
  - **Issuer ID** (*+S*): The *unique ID* of the (parent) certificate used to generate this certificate
  - **Issuer Type** (*+S*): The type of the (parent) certificate used to generate this certificate
- **Public Key** (*+S*): The *public key* used by the certificate
- **Type** (*+S*): The type of the certificate (*numerical value*)

### Root Certificate (10)

> Note that the **Root Certificate (10)**'s validity **Not After** value is `NULL`, meaning that it never expires!

The root certificate is used to generate intermediate certificates. This is a well-known practice, used to ensure that, in the case that an intermediate certificate is compromised, only certificates generated by the intermediate certificate will be affected!

### Intermediate User-Zone Certificate (20)

> Note that the **Intermediate User-Zone Certificate (20)**'s validity **Not After** value is `NULL`, meaning that it never expires!

The *user-zone* intermediate certificate is used to generate *User Certificates*.

### Intermediate Dealing-Zone Certificate (21)

The *dealing-zone* intermediate certificate is used to generate *Trusted Dealings certificates*.

### User Certificate (30)

> Note that the **User Certificate (30)**'s validity **Not After** value is `NULL`, meaning that it never expires!

This certificate's sole use is to trace back generated certificates by the user within the CA's database

- **Subject:**
  - **User ID** (*+S*): the *unique ID* of the user within the accounts system database

### Permission Certificate (31)

This certificate is used to grant authority to a *Dealer* to access user data or perform actions on behalf of the user.

> Note that each time the dealer changes their domains or origin IP address, they need to submit an application to revoke the current certificate and generate a new one!

- **Subject:**
  - **User ID** (*+S*): the *unique ID* of the user within the accounts system database
  - **Dealer ID** (*+S*): the *unique ID* of the *Trusted Dealings Certificate* within the database
  - **Dealer Domains** (*+S*): the list of whitelisted domains provided by the *dealer*
  - **Dealer Origins** (*+S*): the list of whitelisted origin IP addresses provided by the *dealer*

### Trusted Dealings Certificate (40)

This certificate is used to grant authority to *dealers* (services created by Ender or 3rd-parties) to connect to all open APIs run and managed by Ender!

- **Subject:**
  - **Dealer Domains** (*+S*): the list of whitelisted domains provided by the *dealer*
  - **Dealer Origins** (*+S*): the list of whitelisted origin IP addresses provided by the *dealer*

## Certificate Validation

All certificates must go through the following verification steps before the data provided by them is used:

> Note that the checking process is recursive, meaning that the issuers's validity must be check until you reach the root CA certificate

1. The certificate's *revoked* state is checked within the CA database using their *unique ID*.
2. The certificate *issuer*'s validity is checked using their *unique ID*. (should the issuer be invalid, or revoked, all certificates generated by them will be automatically considered invalid)
3. The certificate *issuer*'s type is checked, and, should it not adhere to the [certificate issuer restrictions](#certificate-issuer-restrictions), it will be invalidated.
4. The certificate's validity (date) is checked (should the current timestamp not be within the range of the **Not Before** or **Not After** range, no actions will be allowed, and the certificate will be considered invalid)
5. All other fields are checked to see if they match their signature

> Note that starting from step number 2, there is no need to make any more calls to the Database, since the data used in the steps that follow is signed with an *Enhanced Signature*!

### Certificate Issuer restrictions

The issuer of a certificate must be of a specific type, according to the type of the generated certificate:

- **Root Certificate (10)** issuer field should be empty (the root certificate is identified by a 16bytes *unique ID*)!
- **Intermediate User-Zone Certificate (20)** must be issued by a **Root Certificate (10)**
- **Intermediate Dealing-Zone Certificate (21)** must be issued by a **Root Certificate (10)**
- **User Certificate (30)** must be issued by an **Intermediate User-Zone Certificate (20)**
- **Permission Certificate (31)** must be issued by an **Intermediate User-Zone Certificate (20)**
- **Trusted Dealings Certificate (40)** must be issued by an **Intermediate Dealing-Zone Certificate (21)**
